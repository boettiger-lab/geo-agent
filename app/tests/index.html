<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Map Tools Tests</title>
    <style>
        body {
            font-family: system-ui, -apple-system, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }

        h1 {
            color: #333;
        }

        h2 {
            color: #555;
            margin-top: 30px;
        }

        .test-suite {
            background: white;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .test {
            padding: 10px;
            margin: 5px 0;
            border-left: 4px solid #ddd;
            background: #f9f9f9;
        }

        .test.pass {
            border-left-color: #4caf50;
            background: #e8f5e9;
        }

        .test.fail {
            border-left-color: #f44336;
            background: #ffebee;
        }

        .test-name {
            font-weight: bold;
            margin-bottom: 5px;
        }

        .test-result {
            font-size: 14px;
            color: #666;
        }

        .test-error {
            color: #c62828;
            margin-top: 5px;
            font-family: monospace;
            font-size: 12px;
        }

        .summary {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 4px;
            margin: 20px 0;
        }

        .summary.fail {
            background: #ffcdd2;
        }

        #run-tests {
            background: #2196f3;
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            border-radius: 4px;
            cursor: pointer;
            margin: 20px 0;
        }

        #run-tests:hover {
            background: #1976d2;
        }

        #run-tests:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
    </style>
</head>

<body>
    <h1>Map Tools Test Suite</h1>
    <p>Tests for LayerRegistry, MapLayerController, and MCPToolFactory</p>

    <button id="run-tests">Run All Tests</button>

    <div id="test-results"></div>

    <script type="module">
        import { LayerRegistry } from '../layer-registry.js';
        import { MapLayerController } from '../map-layer-controller.js';
        import { MCPToolFactory } from '../mcp-tool-factory.js';

        class TestRunner {
            constructor() {
                this.results = [];
                this.currentSuite = null;
            }

            suite(name, fn) {
                this.currentSuite = {
                    name,
                    tests: []
                };
                fn();
                this.results.push(this.currentSuite);
                this.currentSuite = null;
            }

            test(name, fn) {
                const test = {
                    name,
                    passed: false,
                    error: null
                };

                try {
                    fn();
                    test.passed = true;
                } catch (error) {
                    test.error = error.message;
                }

                this.currentSuite.tests.push(test);
            }

            assertEqual(actual, expected, message = '') {
                if (actual !== expected) {
                    throw new Error(`${message}\nExpected: ${expected}\nActual: ${actual}`);
                }
            }

            assertTrue(value, message = 'Expected true') {
                if (!value) {
                    throw new Error(message);
                }
            }

            assertFalse(value, message = 'Expected false') {
                if (value) {
                    throw new Error(message);
                }
            }

            assertThrows(fn, message = 'Expected function to throw') {
                try {
                    fn();
                    throw new Error(message);
                } catch (error) {
                    // Expected
                }
            }

            assertDefined(value, message = 'Expected value to be defined') {
                if (value === undefined || value === null) {
                    throw new Error(message);
                }
            }

            render() {
                const container = document.getElementById('test-results');
                container.innerHTML = '';

                let totalTests = 0;
                let totalPassed = 0;

                this.results.forEach(suite => {
                    const suiteDiv = document.createElement('div');
                    suiteDiv.className = 'test-suite';

                    const suiteTitle = document.createElement('h2');
                    suiteTitle.textContent = suite.name;
                    suiteDiv.appendChild(suiteTitle);

                    suite.tests.forEach(test => {
                        totalTests++;
                        if (test.passed) totalPassed++;

                        const testDiv = document.createElement('div');
                        testDiv.className = `test ${test.passed ? 'pass' : 'fail'}`;

                        const testName = document.createElement('div');
                        testName.className = 'test-name';
                        testName.textContent = `${test.passed ? 'âœ“' : 'âœ—'} ${test.name}`;
                        testDiv.appendChild(testName);

                        if (test.error) {
                            const errorDiv = document.createElement('div');
                            errorDiv.className = 'test-error';
                            errorDiv.textContent = test.error;
                            testDiv.appendChild(errorDiv);
                        }

                        suiteDiv.appendChild(testDiv);
                    });

                    container.appendChild(suiteDiv);
                });

                // Add summary
                const summary = document.createElement('div');
                summary.className = `summary ${totalPassed === totalTests ? 'pass' : 'fail'}`;
                summary.innerHTML = `
                    <strong>Test Results:</strong><br>
                    ${totalPassed} / ${totalTests} tests passed
                    ${totalPassed === totalTests ? ' ðŸŽ‰' : ''}
                `;
                container.insertBefore(summary, container.firstChild);
            }
        }

        // Run tests
        document.getElementById('run-tests').addEventListener('click', async function () {
            this.disabled = true;
            this.textContent = 'Running tests...';

            const runner = new TestRunner();

            // LayerRegistry Tests
            runner.suite('LayerRegistry', function () {
                runner.test('should create empty registry', () => {
                    const registry = new LayerRegistry();
                    runner.assertEqual(registry.getKeys().length, 0, 'Registry should be empty');
                });

                runner.test('should register a layer', () => {
                    const registry = new LayerRegistry();
                    registry.register('test', {
                        displayName: 'Test Layer',
                        layerIds: ['test-layer'],
                        checkboxId: 'test-checkbox',
                        isVector: false,
                        hasLegend: false
                    });
                    runner.assertTrue(registry.has('test'), 'Layer should exist');
                    runner.assertEqual(registry.getKeys().length, 1, 'Should have 1 layer');
                });

                runner.test('should get layer metadata', () => {
                    const registry = new LayerRegistry();
                    registry.register('test', {
                        displayName: 'Test Layer',
                        layerIds: ['test-layer'],
                        checkboxId: 'test-checkbox',
                        isVector: true,
                        hasLegend: false,
                        sourceLayer: 'test-source'
                    });
                    const layer = registry.get('test');
                    runner.assertEqual(layer.displayName, 'Test Layer');
                    runner.assertTrue(layer.isVector);
                });

                runner.test('should filter vector layers', () => {
                    const registry = new LayerRegistry();
                    registry.register('raster1', {
                        displayName: 'Raster',
                        layerIds: ['r1'],
                        checkboxId: 'r1-check',
                        isVector: false,
                        hasLegend: false
                    });
                    registry.register('vector1', {
                        displayName: 'Vector',
                        layerIds: ['v1'],
                        checkboxId: 'v1-check',
                        isVector: true,
                        hasLegend: false,
                        sourceLayer: 'v1-source'
                    });
                    const vectorKeys = registry.getVectorKeys();
                    runner.assertEqual(vectorKeys.length, 1);
                    runner.assertEqual(vectorKeys[0], 'vector1');
                });

                runner.test('should map database types correctly', () => {
                    const registry = new LayerRegistry();
                    runner.assertEqual(registry.mapDbTypeToJsonType('INTEGER'), 'number');
                    runner.assertEqual(registry.mapDbTypeToJsonType('VARCHAR'), 'string');
                    runner.assertEqual(registry.mapDbTypeToJsonType('BOOLEAN'), 'boolean');
                    runner.assertEqual(registry.mapDbTypeToJsonType('DOUBLE'), 'number');
                });

                runner.test('should unregister layers', () => {
                    const registry = new LayerRegistry();
                    registry.register('test', {
                        displayName: 'Test',
                        layerIds: ['test'],
                        checkboxId: 'test-check',
                        isVector: false,
                        hasLegend: false
                    });
                    runner.assertTrue(registry.has('test'));
                    registry.unregister('test');
                    runner.assertFalse(registry.has('test'));
                });

                runner.test('should validate required fields', () => {
                    const registry = new LayerRegistry();
                    runner.assertThrows(() => {
                        registry.register('invalid', {
                            // Missing displayName
                            layerIds: ['test'],
                            checkboxId: 'test-check',
                            isVector: false,
                            hasLegend: false
                        });
                    }, 'Should throw for missing displayName');
                });

                runner.test('should validate vector layer requirements', () => {
                    const registry = new LayerRegistry();
                    runner.assertThrows(() => {
                        registry.register('invalid-vector', {
                            displayName: 'Invalid Vector',
                            layerIds: ['test'],
                            checkboxId: 'test-check',
                            isVector: true,
                            hasLegend: false
                            // Missing sourceLayer
                        });
                    }, 'Should throw for vector layer without sourceLayer');
                });
            });

            // MapLayerController Tests (with mock map)
            runner.suite('MapLayerController', function () {
                // Create mock map
                const createMockMap = () => ({
                    layers: {},
                    getLayer: function (id) {
                        return this.layers[id];
                    },
                    setLayoutProperty: function (id, prop, value) {
                        if (!this.layers[id]) this.layers[id] = {};
                        if (!this.layers[id].layout) this.layers[id].layout = {};
                        this.layers[id].layout[prop] = value;
                    },
                    setFilter: function (id, filter) {
                        if (!this.layers[id]) this.layers[id] = {};
                        this.layers[id].filter = filter;
                    },
                    setPaintProperty: function (id, prop, value) {
                        if (!this.layers[id]) this.layers[id] = {};
                        if (!this.layers[id].paint) this.layers[id].paint = {};
                        this.layers[id].paint[prop] = value;
                    },
                    getPaintProperty: function (id, prop) {
                        return this.layers[id]?.paint?.[prop];
                    }
                });

                runner.test('should create controller', () => {
                    const registry = new LayerRegistry();
                    const map = createMockMap();
                    const controller = new MapLayerController(map, registry);
                    runner.assertDefined(controller);
                });

                runner.test('should describe simple filter', () => {
                    const registry = new LayerRegistry();
                    const map = createMockMap();
                    const controller = new MapLayerController(map, registry);

                    const desc1 = controller.describeFilter(['==', 'IUCN_CAT', 'II']);
                    runner.assertTrue(desc1.includes('equals'));

                    const desc2 = controller.describeFilter(['>', 'area', 1000]);
                    runner.assertTrue(desc2.includes('greater than'));
                });

                runner.test('should describe compound filter', () => {
                    const registry = new LayerRegistry();
                    const map = createMockMap();
                    const controller = new MapLayerController(map, registry);

                    const desc = controller.describeFilter([
                        'all',
                        ['==', 'type', 'park'],
                        ['>', 'area', 100]
                    ]);
                    runner.assertTrue(desc.includes('AND'));
                });
            });

            // MCPToolFactory Tests
            runner.suite('MCPToolFactory', function () {
                runner.test('should create tool factory', () => {
                    const registry = new LayerRegistry();
                    const mockController = {};
                    const factory = new MCPToolFactory(registry, mockController);
                    runner.assertDefined(factory);
                });

                runner.test('should generate tools', () => {
                    const registry = new LayerRegistry();
                    registry.register('test', {
                        displayName: 'Test',
                        layerIds: ['test'],
                        checkboxId: 'test-check',
                        isVector: false,
                        hasLegend: false
                    });
                    const mockController = {};
                    const factory = new MCPToolFactory(registry, mockController);
                    const tools = factory.generateTools();

                    runner.assertTrue(tools.length > 0, 'Should generate tools');
                    runner.assertTrue(tools.every(t => t.name && t.description && t.inputSchema));
                });

                runner.test('should include all tool types', () => {
                    const registry = new LayerRegistry();
                    registry.register('vector', {
                        displayName: 'Vector Layer',
                        layerIds: ['v'],
                        checkboxId: 'v-check',
                        isVector: true,
                        hasLegend: false,
                        sourceLayer: 'v-source'
                    });
                    const mockController = {};
                    const factory = new MCPToolFactory(registry, mockController);
                    const tools = factory.generateTools();
                    const toolNames = tools.map(t => t.name);

                    runner.assertTrue(toolNames.includes('toggle_map_layer'));
                    runner.assertTrue(toolNames.includes('get_map_layers'));
                    runner.assertTrue(toolNames.includes('filter_map_layer'));
                    runner.assertTrue(toolNames.includes('set_layer_paint'));
                });

                runner.test('should use dynamic enum values', () => {
                    const registry = new LayerRegistry();
                    registry.register('layer1', {
                        displayName: 'Layer 1',
                        layerIds: ['l1'],
                        checkboxId: 'l1-check',
                        isVector: false,
                        hasLegend: false
                    });
                    registry.register('layer2', {
                        displayName: 'Layer 2',
                        layerIds: ['l2'],
                        checkboxId: 'l2-check',
                        isVector: true,
                        hasLegend: false,
                        sourceLayer: 'l2-source'
                    });

                    const mockController = {};
                    const factory = new MCPToolFactory(registry, mockController);
                    const tools = factory.generateTools();
                    const toggleTool = tools.find(t => t.name === 'toggle_map_layer');

                    runner.assertTrue(toggleTool.inputSchema.properties.layer.enum.includes('layer1'));
                    runner.assertTrue(toggleTool.inputSchema.properties.layer.enum.includes('layer2'));
                });
            });

            // Integration Tests
            runner.suite('Integration', function () {
                runner.test('should load from JSON config', async () => {
                    const registry = new LayerRegistry();
                    try {
                        await registry.loadFromJson('../layers-config.json');
                        runner.assertTrue(registry.getKeys().length > 0, 'Should load layers');
                        runner.assertTrue(registry.has('wetlands'), 'Should have wetlands layer');
                        runner.assertTrue(registry.has('wdpa'), 'Should have WDPA layer');
                    } catch (error) {
                        throw new Error(`Failed to load config: ${error.message}`);
                    }
                });

                runner.test('should have filterable properties for vector layers', async () => {
                    const registry = new LayerRegistry();
                    await registry.loadFromJson('../layers-config.json');

                    const wdpa = registry.get('wdpa');
                    runner.assertTrue(wdpa.isVector, 'WDPA should be vector');
                    runner.assertDefined(wdpa.filterableProperties, 'Should have filterable properties');
                    runner.assertTrue('IUCN_CAT' in wdpa.filterableProperties, 'Should have IUCN_CAT property');
                });

                runner.test('should match PMTiles source to data table path', async () => {
                    const registry = new LayerRegistry();
                    await registry.loadFromJson('../layers-config.json');

                    const ramsar = registry.get('ramsar');
                    runner.assertDefined(ramsar.sourceUrl, 'Should have source URL');
                    runner.assertDefined(ramsar.dataTablePath, 'Should have data table path');
                    runner.assertTrue(ramsar.sourceUrl.includes('pmtiles'), 'Source should be PMTiles');
                    runner.assertTrue(ramsar.dataTablePath.includes('s3://'), 'Data path should be S3');
                });
            });

            runner.render();

            this.disabled = false;
            this.textContent = 'Run All Tests';
        });

        // Auto-run tests on page load
        window.addEventListener('load', () => {
            document.getElementById('run-tests').click();
        });
    </script>
</body>

</html>